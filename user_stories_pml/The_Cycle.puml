@startuml GameLauncher

title GameLauncher

' ===========================
' Launcher & Menu
' ===========================

class App {
    + main(): void
}
App --> GameLauncher : calls getInstance()

class GameLauncher {
    - static instance : GameLauncher
    - GameLauncher()
    + static getInstance(): GameLauncher
    + launch(): void
}

class MainMenu {
    + show(): void
}

GameLauncher --> MainMenu : launch()

' ===========================
' Game Creation (Factory Method)
' ===========================

abstract class GameCreator {
    + createGame(): Game
}

class NewGameCreator {
    + createGame(): Game
}

class ContinueGameCreator {
    + createGame(): Game
}

GameCreator <|-- NewGameCreator
GameCreator <|-- ContinueGameCreator
GameCreator --> Game : create()

abstract class Game {
    - gameState: GameState
}

class NewGame
class ContinueGame

Game <|-- NewGame
Game <|-- ContinueGame

class NewGameView {
    + render(): void
}

class SaveMenuView {
    + render(): void
}

NewGame --> NewGameView
ContinueGameCreator --> SaveMenuView

' ===========================
' Singleton GameInstance
' ===========================

class GameInstance {
    - static instance: GameInstance
    - gameCreator: GameCreator
    + getInstance(): GameInstance
}

GameInstance --> GameCreator

class MainMenuController {
    + handleSelection(option: String): void
}

MainMenu --> MainMenuController : user input
MainMenuController --> GameCreator : createGame()
MainMenuController --> GameView : render()

' ===========================
' Character Creation (Abstract Factory)
' ===========================

abstract class CharacterPG {
    - currentMove: List<Move>
    - job: Job
    - baseStats: Stats
    - currentStats: Stats
    - position: Position
    - inCombat: boolean

    + refreshCurrentStats(): void
    + enterCombat(): void
    + exitCombat(): void
    + isInCombat(): boolean
    + createCharacterSprite(): ImageView
    + getCurrentMove(): List<Move>
    + takeDamage(int value): void
    + heal(int value): void
}

class Player extends CharacterPG {
    - xp: int
    - follower: Player
    - imgSprite: Image

    + notifyFollower(): void
    + learnMove(move: Move): void
    + subscribeToFollowed(): void
    + unsubscribeFromFollowed(): void
    + addXp(): void
    + takeDamage(int value): void
    + heal(int value): void
    + hasAbility(): boolean
}

class Enemy extends CharacterPG {
    - imgSprite: Image
    + takeDamage(int value): void
    + heal(int value): void
}

interface Interactable {
    + interact(player: Player): void
}

abstract class NPC implements Interactable {
    - sprite: ImageView
    - job: Job
    - pos: Position
    - dialogue: Dialogue
    - shopMoves: List<Move>

    + getJob(): Job
    + addShopMove(move: Move): void
    + interact(player: Player): void
}

class MovesNPC extends NPC {
    + interact(player: Player): void
}

enum Job{
    - col: int
    - row: int
    - baseStats: Stats
    - isPlayable: boolean
    - effectiveMoves: List<Move>

    +getX(): int
    +getY(): int
    +getIsPlayable: boolean
    +getBaseStats(): Stats
    + initAllMoves(): void
    + getShopMoves(): List<Move>
    + getEffectiveMoves(): List<Move>
}

CharacterSelectionView --> GameController : user selects job
NewGameView --> CharacterSelectionView : selectJobs()
GameController --> Player : createParty()
GameController --> Enemy : createEnemy()
Player --> Job
Enemy --> Job

' ===========================
' Strategy Pattern (Move)
' ===========================

class Move {
    - id: String
    - name: String
    - type: MoveType
    - value: int
    - cost: int
    - req: List<String>
    - description: String
    + getId(): String
    + getName(): String
    + getType(): MoveType
    + getValue(): int
    + getCost(): int
    + getReq(): List<String>
    + getDescription(): String
}

interface ActionStrategy {
    + execute(user: Character, target: Character)
}

enum MoveType {
    +createMove(move: Move): ActionStrategy
}

abstract class MoveAction implements ActionStrategy{
    - move: Move
    - combatStrategy: CombatCalculationStrategy
    + execute(user,target)
}

abstract class OffensiveMove extends MoveAction {
    - move: Move
    + execute(user,target)
    + calculateDamage(user,target)
}

class AttackMove extends OffensiveMove {
    - move: Move
    + execute(user,target)
    + calculateDamage(user,target)
}

class HealMove extends MoveAction {
    - move: Move
    + execute(user,target)
}

class MagicAttackMove extends OffensiveMove {
    - move: Move
    + execute(user,target)
    + calculateDamage(user,target)
}

class ItemAction implements ActionStrategy{
    - item: Item
    + execute(user, target)
}

Player ..> ActionStrategy : uses
Player..>Move: stores
Enemy..>ActionStrategy : uses
MoveType..>MoveAction: creates

' ===========================
' Shop
' ===========================

class ShopView {
    - player: Player
    + addShopItem(move: Move): void
    + showFeedback(moveName: String): void
    + updateUI(): void
    + open(npc: NPC): void
    + closed(): void

}

ShopView --> Player: interacts
ShopView --> NPC: showShop
'Indica dipendenza perchÃ¨ shopview ha bisogno di Move per creare UI'
ShopView ..> Move : add()

' ===========================
' Builder Pattern (Map)
' ===========================

class MapBuilder {
    - map: MapView
    + addLayer(layer)
    + build()
}

class ExplorationView {
    + renderMap()
}

class ExplorationController {
    + movePlayer(direction)
    + updatePartyFollow()
}

ExplorationView --> ExplorationController
ExplorationView --> MapBuilder
CharacterSelectionView --> ExplorationView : startExploration()

@enduml